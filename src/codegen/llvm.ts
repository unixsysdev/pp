// Phase 6: LLVM Code Generation Backend
// src/codegen/llvm.ts
// Phase 6: LLVM Code Generation Backend

import { ASTNode, Statement, Expression, FunctionDeclaration, VariableDeclaration, 
         BinaryExpression, NumberLiteral, StringLiteral, BooleanLiteral, 
         Identifier, FunctionCall, IfStatement, ReturnStatement } from '../ast/nodes';
import { Type, PrimitiveType, FunctionType, ResultType, OptionType } from '../types/types';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// ============================================================================
// LLVM IR GENERATION
// ============================================================================

export class LLVMCodeGenerator {
  private output: string[] = [];
  private labelCounter = 0;
  private localCounter = 0;
  private functions = new Map<string, LLVMFunction>();
  private globals = new Map<string, LLVMValue>();
  private currentFunction: LLVMFunction | null = null;
  private stringLiterals = new Map<string, string>();
  private stringCounter = 0;

  generate(statements: Statement[]): string {
    this.emitHeader();
    this.emitBuiltinDeclarations();
    
    // First pass: collect function signatures
    for (const stmt of statements) {
      if (stmt instanceof FunctionDeclaration) {
        this.collectFunctionSignature(stmt);
      }
    }

    // Second pass: generate code
    for (const stmt of statements) {
      this.generateStatement(stmt);
    }

    this.emitStringLiterals();
    this.emitMain();
    
    return this.output.join('\n');
  }

  private emitHeader(): void {
    this.emit('; Enterprise Language LLVM IR');
    this.emit('; Generated by Enterprise Lang Compiler');
    this.emit('');
    this.emit('target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"');
    this.emit('target triple = "x86_64-unknown-linux-gnu"');
    this.emit('');
  }

  private emitBuiltinDeclarations(): void {
    this.emit('; Built-in function declarations');
    this.emit('declare i32 @printf(i8*, ...)');
    this.emit('declare i32 @scanf(i8*, ...)');
    this.emit('declare i8* @malloc(i64)');
    this.emit('declare void @free(i8*)');
    this.emit('declare i32 @strlen(i8*)');
    this.emit('declare i8* @strcpy(i8*, i8*)');
    this.emit('declare i32 @strcmp(i8*, i8*)');
    this.emit('');
  }

  private collectFunctionSignature(func: FunctionDeclaration): void {
    const paramTypes = func.params.map(p => this.typeToLLVM(p.type));
    const returnType = this.typeToLLVM(func.returnType);
    
    const llvmFunc = new LLVMFunction(
      func.name,
      returnType,
      paramTypes,
      func.params.map(p => p.name)
    );
    
    this.functions.set(func.name, llvmFunc);
  }

  private generateStatement(stmt: Statement): void {
    if (stmt instanceof FunctionDeclaration) {
      this.generateFunction(stmt);
    } else if (stmt instanceof VariableDeclaration) {
      this.generateGlobalVariable(stmt);
    }
  }

  private generateFunction(func: FunctionDeclaration): void {
    const llvmFunc = this.functions.get(func.name)!;
    this.currentFunction = llvmFunc;
    
    // Function header
    const params = llvmFunc.paramTypes
      .map((type, i) => `${type} %${llvmFunc.paramNames[i]}`)
      .join(', ');
    
    this.emit(`define ${llvmFunc.returnType} @${func.name}(${params}) {`);
    this.emit('entry:');
    
    // Allocate space for parameters (for mutable access)
    for (let i = 0; i < func.params.length; i++) {
      const paramName = func.params[i].name;
      const paramType = this.typeToLLVM(func.params[i].type);
      const allocaName = this.newLocal();
      
      this.emit(`  ${allocaName} = alloca ${paramType}`);
      this.emit(`  store ${paramType} %${paramName}, ${paramType}* ${allocaName}`);
      llvmFunc.locals.set(paramName, new LLVMValue(allocaName, paramType, true));
    }

    // Generate function body
    let hasReturn = false;
    for (const bodyStmt of func.body) {
      if (bodyStmt instanceof ReturnStatement) {
        hasReturn = true;
      }
      this.generateFunctionStatement(bodyStmt);
    }

    // Add default return if needed
    if (!hasReturn) {
      if (func.returnType instanceof PrimitiveType && func.returnType.name === 'void') {
        this.emit('  ret void');
      } else {
        const defaultValue = this.getDefaultValue(func.returnType);
        this.emit(`  ret ${this.typeToLLVM(func.returnType)} ${defaultValue}`);
      }
    }

    this.emit('}');
    this.emit('');
    this.currentFunction = null;
  }

  private generateFunctionStatement(stmt: Statement): void {
    if (stmt instanceof VariableDeclaration) {
      this.generateLocalVariable(stmt);
    } else if (stmt instanceof IfStatement) {
      this.generateIfStatement(stmt);
    } else if (stmt instanceof ReturnStatement) {
      this.generateReturnStatement(stmt);
    } else if (stmt instanceof ExpressionStatement) {
      this.generateExpression(stmt.expression);
    }
  }

  private generateLocalVariable(stmt: VariableDeclaration): void {
    const varType = this.typeToLLVM(stmt.typeAnnotation!);
    const allocaName = this.newLocal();
    
    this.emit(`  ${allocaName} = alloca ${varType}`);
    
    if (stmt.initializer) {
      const initValue = this.generateExpression(stmt.initializer);
      this.emit(`  store ${varType} ${initValue.name}, ${varType}* ${allocaName}`);
    }
    
    this.currentFunction!.locals.set(stmt.name, new LLVMValue(allocaName, varType, true));
  }

  private generateIfStatement(stmt: IfStatement): void {
    const condValue = this.generateExpression(stmt.condition);
    const thenLabel = this.newLabel('if.then');
    const elseLabel = this.newLabel('if.else');
    const endLabel = this.newLabel('if.end');

    // Convert condition to i1 if needed
    let condName = condValue.name;
    if (condValue.type !== 'i1') {
      const cmpResult = this.newLocal();
      this.emit(`  ${cmpResult} = icmp ne ${condValue.type} ${condValue.name}, 0`);
      condName = cmpResult;
    }

    if (stmt.elseBranch) {
      this.emit(`  br i1 ${condName}, label %${thenLabel}, label %${elseLabel}`);
    } else {
      this.emit(`  br i1 ${condName}, label %${thenLabel}, label %${endLabel}`);
    }

    // Then branch
    this.emit(`${thenLabel}:`);
    for (const thenStmt of stmt.thenBranch) {
      this.generateFunctionStatement(thenStmt);
    }
    this.emit(`  br label %${endLabel}`);

    // Else branch
    if (stmt.elseBranch) {
      this.emit(`${elseLabel}:`);
      for (const elseStmt of stmt.elseBranch) {
        this.generateFunctionStatement(elseStmt);
      }
      this.emit(`  br label %${endLabel}`);
    }

    // End label
    this.emit(`${endLabel}:`);
  }

  private generateReturnStatement(stmt: ReturnStatement): void {
    if (stmt.value) {
      const retValue = this.generateExpression(stmt.value);
      this.emit(`  ret ${retValue.type} ${retValue.name}`);
    } else {
      this.emit('  ret void');
    }
  }

  private generateExpression(expr: Expression): LLVMValue {
    if (expr instanceof NumberLiteral) {
      return new LLVMValue(expr.value.toString(), 'double', false);
    } else if (expr instanceof StringLiteral) {
      return this.generateStringLiteral(expr.value);
    } else if (expr instanceof BooleanLiteral) {
      return new LLVMValue(expr.value ? '1' : '0', 'i1', false);
    } else if (expr instanceof Identifier) {
      return this.generateIdentifier(expr.name);
    } else if (expr instanceof BinaryExpression) {
      return this.generateBinaryExpression(expr);
    } else if (expr instanceof FunctionCall) {
      return this.generateFunctionCall(expr);
    }
    
    throw new Error(`Unsupported expression type: ${expr.constructor.name}`);
  }

  private generateStringLiteral(value: string): LLVMValue {
    if (!this.stringLiterals.has(value)) {
      const globalName = `@.str.${this.stringCounter++}`;
      this.stringLiterals.set(value, globalName);
    }
    
    const globalName = this.stringLiterals.get(value)!;
    const localName = this.newLocal();
    
    this.emit(`  ${localName} = getelementptr inbounds [${value.length + 1} x i8], [${value.length + 1} x i8]* ${globalName}, i64 0, i64 0`);
    
    return new LLVMValue(localName, 'i8*', false);
  }

  private generateIdentifier(name: string): LLVMValue {
    const local = this.currentFunction!.locals.get(name);
    if (local) {
      if (local.isPointer) {
        const loadResult = this.newLocal();
        const baseType = local.type.replace('*', '');
        this.emit(`  ${loadResult} = load ${baseType}, ${local.type} ${local.name}`);
        return new LLVMValue(loadResult, baseType, false);
      }
      return local;
    }

    const global = this.globals.get(name);
    if (global) {
      return global;
    }

    throw new Error(`Undefined variable: ${name}`);
  }

  private generateBinaryExpression(expr: BinaryExpression): LLVMValue {
    const left = this.generateExpression(expr.left);
    const right = this.generateExpression(expr.right);
    const result = this.newLocal();

    switch (expr.operator) {
      case '+':
        if (left.type === 'double' && right.type === 'double') {
          this.emit(`  ${result} = fadd double ${left.name}, ${right.name}`);
          return new LLVMValue(result, 'double', false);
        }
        break;
      case '-':
        if (left.type === 'double' && right.type === 'double') {
          this.emit(`  ${result} = fsub double ${left.name}, ${right.name}`);
          return new LLVMValue(result, 'double', false);
        }
        break;
      case '*':
        if (left.type === 'double' && right.type === 'double') {
          this.emit(`  ${result} = fmul double ${left.name}, ${right.name}`);
          return new LLVMValue(result, 'double', false);
        }
        break;
      case '/':
        if (left.type === 'double' && right.type === 'double') {
          this.emit(`  ${result} = fdiv double ${left.name}, ${right.name}`);
          return new LLVMValue(result, 'double', false);
        }
        break;
      case '==':
        if (left.type === 'double' && right.type === 'double') {
          this.emit(`  ${result} = fcmp oeq double ${left.name}, ${right.name}`);
          return new LLVMValue(result, 'i1', false);
        }
        break;
      case '!=':
        if (left.type === 'double' && right.type === 'double') {
          this.emit(`  ${result} = fcmp one double ${left.name}, ${right.name}`);
          return new LLVMValue(result, 'i1', false);
        }
        break;
      case '<':
        if (left.type === 'double' && right.type === 'double') {
          this.emit(`  ${result} = fcmp olt double ${left.name}, ${right.name}`);
          return new LLVMValue(result, 'i1', false);
        }
        break;
      case '>':
        if (left.type === 'double' && right.type === 'double') {
          this.emit(`  ${result} = fcmp ogt double ${left.name}, ${right.name}`);
          return new LLVMValue(result, 'i1', false);
        }
        break;
    }

    throw new Error(`Unsupported binary operation: ${left.type} ${expr.operator} ${right.type}`);
  }

  private generateFunctionCall(expr: FunctionCall): LLVMValue {
    if (expr.callee instanceof Identifier) {
      const funcName = expr.callee.name;
      
      // Handle built-in functions
      if (funcName === 'print') {
        return this.generatePrintCall(expr.args);
      }

      const func = this.functions.get(funcName);
      if (func) {
        const args = expr.args.map((arg, i) => {
          const argValue = this.generateExpression(arg);
          return `${func.paramTypes[i]} ${argValue.name}`;
        }).join(', ');

        if (func.returnType === 'void') {
          this.emit(`  call void @${funcName}(${args})`);
          return new LLVMValue('0', 'void', false);
        } else {
          const result = this.newLocal();
          this.emit(`  ${result} = call ${func.returnType} @${funcName}(${args})`);
          return new LLVMValue(result, func.returnType, false);
        }
      }
    }

    throw new Error(`Unsupported function call: ${expr.callee}`);
  }

  private generatePrintCall(args: Expression[]): LLVMValue {
    if (args.length === 1) {
      const arg = this.generateExpression(args[0]);
      
      if (arg.type === 'double') {
        const formatStr = this.getOrCreateStringLiteral('%.2f\\n');
        this.emit(`  call i32 (i8*, ...) @printf(i8* ${formatStr}, double ${arg.name})`);
      } else if (arg.type === 'i8*') {
        const formatStr = this.getOrCreateStringLiteral('%s\\n');
        this.emit(`  call i32 (i8*, ...) @printf(i8* ${formatStr}, i8* ${arg.name})`);
      } else if (arg.type === 'i1') {
        const trueStr = this.getOrCreateStringLiteral('true\\n');
        const falseStr = this.getOrCreateStringLiteral('false\\n');
        const result = this.newLocal();
        const thenLabel = this.newLabel('print.true');
        const elseLabel = this.newLabel('print.false');
        const endLabel = this.newLabel('print.end');
        
        this.emit(`  br i1 ${arg.name}, label %${thenLabel}, label %${elseLabel}`);
        this.emit(`${thenLabel}:`);
        this.emit(`  call i32 (i8*, ...) @printf(i8* ${trueStr})`);
        this.emit(`  br label %${endLabel}`);
        this.emit(`${elseLabel}:`);
        this.emit(`  call i32 (i8*, ...) @printf(i8* ${falseStr})`);
        this.emit(`  br label %${endLabel}`);
        this.emit(`${endLabel}:`);
      }
    }

    return new LLVMValue('0', 'i32', false);
  }

  private generateGlobalVariable(stmt: VariableDeclaration): void {
    const varType = this.typeToLLVM(stmt.typeAnnotation!);
    const globalName = `@${stmt.name}`;
    
    let initialValue = this.getDefaultValue(stmt.typeAnnotation!);
    if (stmt.initializer && stmt.initializer instanceof NumberLiteral) {
      initialValue = stmt.initializer.value.toString();
    }

    this.emit(`${globalName} = global ${varType} ${initialValue}`);
    this.globals.set(stmt.name, new LLVMValue(globalName, varType + '*', true));
  }

  private emitStringLiterals(): void {
    this.emit('; String literals');
    for (const [value, globalName] of this.stringLiterals) {
      const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
      this.emit(`${globalName} = private unnamed_addr constant [${value.length + 1} x i8] c"${escaped}\\00"`);
    }
    this.emit('');
  }

  private emitMain(): void {
    this.emit('define i32 @main() {');
    this.emit('entry:');
    
    // Call main function if it exists
    if (this.functions.has('main')) {
      this.emit('  call void @main()');
    }
    
    this.emit('  ret i32 0');
    this.emit('}');
  }

  private getOrCreateStringLiteral(value: string): string {
    if (!this.stringLiterals.has(value)) {
      const globalName = `@.str.${this.stringCounter++}`;
      this.stringLiterals.set(value, globalName);
    }
    return this.stringLiterals.get(value)!;
  }

  private typeToLLVM(type: Type): string {
    if (type instanceof PrimitiveType) {
      switch (type.name) {
        case 'number': return 'double';
        case 'string': return 'i8*';
        case 'boolean': return 'i1';
        case 'void': return 'void';
        default: return 'i8*'; // Default to pointer
      }
    } else if (type instanceof FunctionType) {
      const params = type.params.map(p => this.typeToLLVM(p)).join(', ');
      const ret = this.typeToLLVM(type.returnType);
      return `${ret} (${params})*`;
    }
    
    return 'i8*'; // Default to pointer for complex types
  }

  private getDefaultValue(type: Type): string {
    if (type instanceof PrimitiveType) {
      switch (type.name) {
        case 'number': return '0.0';
        case 'string': return 'null';
        case 'boolean': return 'false';
        default: return 'null';
      }
    }
    return 'null';
  }

  private emit(line: string): void {
    this.output.push(line);
  }

  private newLabel(prefix: string = 'label'): string {
    return `${prefix}.${this.labelCounter++}`;
  }

  private newLocal(): string {
    return `%${this.localCounter++}`;
  }
}

class LLVMFunction {
  public locals = new Map<string, LLVMValue>();

  constructor(
    public name: string,
    public returnType: string,
    public paramTypes: string[],
    public paramNames: string[]
  ) {}
}

class LLVMValue {
  constructor(
    public name: string,
    public type: string,
    public isPointer: boolean
  ) {}
}

// ============================================================================
// OPTIMIZATION PASSES
// ============================================================================

export class OptimizationManager {
  private passes: OptimizationPass[] = [];

  addPass(pass: OptimizationPass): void {
    this.passes.push(pass);
  }

  optimize(llvmIR: string): string {
    let optimized = llvmIR;
    
    for (const pass of this.passes) {
      optimized = pass.run(optimized);
    }
    
    return optimized;
  }

  static createDefaultPasses(): OptimizationManager {
    const manager = new OptimizationManager();
    
    manager.addPass(new DeadCodeEliminationPass());
    manager.addPass(new ConstantFoldingPass());
    manager.addPass(new CommonSubexpressionEliminationPass());
    manager.addPass(new InliningPass());
    
    return manager;
  }
}

abstract class OptimizationPass {
  abstract run(llvmIR: string): string;
}

class DeadCodeEliminationPass extends OptimizationPass {
  run(llvmIR: string): string {
    // Simple dead code elimination - remove unused variables
    const lines = llvmIR.split('\n');
    const usedVariables = new Set<string>();
    const definitions = new Map<string, number>();

    // Find all variable uses
    lines.forEach((line, index) => {
      const match = line.match(/%(\w+)/g);
      if (match) {
        match.forEach(variable => {
          usedVariables.add(variable);
        });
      }

      // Track definitions
      const defMatch = line.match(/^\s*(%\w+)\s*=/);
      if (defMatch) {
        definitions.set(defMatch[1], index);
      }
    });

    // Remove unused definitions
    const filtered = lines.filter((line, index) => {
      const defMatch = line.match(/^\s*(%\w+)\s*=/);
      if (defMatch) {
        return usedVariables.has(defMatch[1]);
      }
      return true;
    });

    return filtered.join('\n');
  }
}

class ConstantFoldingPass extends OptimizationPass {
  run(llvmIR: string): string {
    return llvmIR.replace(
      /(\w+) = fadd double ([\d.]+), ([\d.]+)/g,
      (match, result, left, right) => {
        const sum = parseFloat(left) + parseFloat(right);
        return `${result} = fadd double ${left}, ${right} ; folded to ${sum}`;
      }
    );
  }
}

class CommonSubexpressionEliminationPass extends OptimizationPass {
  run(llvmIR: string): string {
    // Basic CSE - find duplicate expressions
    const lines = llvmIR.split('\n');
    const expressions = new Map<string, string>();
    
    const processed = lines.map(line => {
      const match = line.match(/^\s*(%\w+)\s*=\s*(.+)$/);
      if (match) {
        const [, variable, expression] = match;
        const normalizedExpr = this.normalizeExpression(expression);
        
        if (expressions.has(normalizedExpr)) {
          const existingVar = expressions.get(normalizedExpr)!;
          return `  ; CSE: ${variable} = ${existingVar}`;
        } else {
          expressions.set(normalizedExpr, variable);
        }
      }
      return line;
    });

    return processed.join('\n');
  }

  private normalizeExpression(expr: string): string {
    // Simple normalization - sort commutative operations
    return expr.replace(/(\w+) ([\d.]+), ([\d.]+)/, (match, op, a, b) => {
      if (['fadd', 'fmul'].includes(op)) {
        const sorted = [a, b].sort();
        return `${op} ${sorted[0]}, ${sorted[1]}`;
      }
      return match;
    });
  }
}

class InliningPass extends OptimizationPass {
  run(llvmIR: string): string {
    // Simple function inlining for small functions
    const lines = llvmIR.split('\n');
    const functions = this.extractFunctions(lines);
    
    // Inline small functions (< 5 instructions)
    let processed = lines.join('\n');
    
    for (const [name, func] of functions) {
      if (func.instructions.length < 5 && !func.recursive) {
        processed = this.inlineFunction(processed, name, func);
      }
    }
    
    return processed;
  }

  private extractFunctions(lines: string[]): Map<string, FunctionInfo> {
    const functions = new Map<string, FunctionInfo>();
    let currentFunc: FunctionInfo | null = null;
    
    for (const line of lines) {
      const funcMatch = line.match(/^define\s+\w+\s+@(\w+)\(/);
      if (funcMatch) {
        currentFunc = new FunctionInfo(funcMatch[1]);
        continue;
      }
      
      if (line === '}' && currentFunc) {
        functions.set(currentFunc.name, currentFunc);
        currentFunc = null;
        continue;
      }
      
      if (currentFunc && line.trim() && !line.includes(':')) {
        currentFunc.instructions.push(line);
        
        // Check for recursion
        if (line.includes(`@${currentFunc.name}`)) {
          currentFunc.recursive = true;
        }
      }
    }
    
    return functions;
  }

  private inlineFunction(llvmIR: string, name: string, func: FunctionInfo): string {
    // Replace function calls with inlined body
    const callRegex = new RegExp(`call\\s+\\w+\\s+@${name}\\([^)]*\\)`, 'g');
    
    return llvmIR.replace(callRegex, (match) => {
      return `; Inlined ${name}\n${func.instructions.join('\n')}`;
    });
  }
}

class FunctionInfo {
  public instructions: string[] = [];
  public recursive = false;

  constructor(public name: string) {}
}

// ============================================================================
// NATIVE COMPILATION
// ============================================================================

export class NativeCompiler {
  constructor(
    private llcPath: string = 'llc',
    private clangPath: string = 'clang'
  ) {}

  async compileToObject(llvmIR: string, outputPath: string): Promise<void> {
    // Write LLVM IR to temporary file
    const irPath = outputPath.replace(/\.[^.]+$/, '.ll');
    await fs.promises.writeFile(irPath, llvmIR);

    // Compile to object file
    const objPath = outputPath.replace(/\.[^.]+$/, '.o');
    await execAsync(`${this.llcPath} -filetype=obj -o ${objPath} ${irPath}`);
  }

  async linkExecutable(objectFiles: string[], outputPath: string): Promise<void> {
    const objectList = objectFiles.join(' ');
    await execAsync(`${this.clangPath} -o ${outputPath} ${objectList}`);
  }

  async compileAndLink(llvmIR: string, outputPath: string): Promise<void> {
    const objPath = outputPath.replace(/\.[^.]+$/, '.o');
    
    await this.compileToObject(llvmIR, objPath);
    await this.linkExecutable([objPath], outputPath);
    
    // Clean up intermediate files
    await fs.promises.unlink(objPath);
    const irPath = outputPath.replace(/\.[^.]+$/, '.ll');
    if (fs.existsSync(irPath)) {
      await fs.promises.unlink(irPath);
    }
  }
}

// ============================================================================
// TARGET CONFIGURATION
// ============================================================================

export class TargetConfig {
  constructor(
    public architecture: string = 'x86_64',
    public operatingSystem: string = 'linux',
    public abi: string = 'gnu'
  ) {}

  getTriple(): string {
    return `${this.architecture}-unknown-${this.operatingSystem}-${this.abi}`;
  }

  getDataLayout(): string {
    // x86_64 data layout
    return 'e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128';
  }

  static getPresetConfigs(): Record<string, TargetConfig> {
    return {
      'linux-x64': new TargetConfig('x86_64', 'linux', 'gnu'),
      'macos-x64': new TargetConfig('x86_64', 'apple', 'darwin'),
      'windows-x64': new TargetConfig('x86_64', 'pc', 'windows-gnu'),
      'linux-arm64': new TargetConfig('aarch64', 'linux', 'gnu'),
      'wasm32': new TargetConfig('wasm32', 'unknown', 'unknown')
    };
  }
}
